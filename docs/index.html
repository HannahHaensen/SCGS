<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Hannah Schieber</title>

    <meta name="author" content="Hannah Schieber">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="images/favicon/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" type="text/css" href="stylesheet.css">
    <meta content="Semantics-Controlled Gaussian Splatting for Outdoor Scene Reconstruction and Rendering in Virtual Reality"
          property="og:title">
    <meta content="Semantics-Controlled Gaussian Splatting for Outdoor Scene Reconstruction and Rendering in Virtual Reality"
          property="description">
    <meta content="Gaussian Splatting" property="description">
    <meta content="Semantic Gaussian Splatting" property="description">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
          integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    <!-- jQuery fÃ¼r Bildwechsel -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>

    <script type="text/javascript">
        $(document).ready(function () {
            /** global: Hammer */
            ;(function ($, window) {
                "use strict";

                function stringRepeat(s, precision) {
                    // String repeat polyfill
                    if (!String.prototype.repeat) {
                        precision = precision || 1;
                        return new Array(precision + 1).join(s);
                    }
                    return s.repeat(precision);
                }

                var pluginName = 'imagesCompare',
                    defaults = {
                        initVisibleRatio: 0.5,
                        interactionMode: "drag", // "drag", "mousemove", "click"
                        animationDuration: 400, // default animation duration in ms
                        animationEasing: "swing",
                        addSeparator: true, // add a html element on the separation
                        addDragHandle: true, // add a html drag handle element on the separation
                        precision: 4
                    };

                // Our object, using revealing module pattern
                function ImagesCompare(element, options) {
                    element = $(element);
                    options = $.extend({}, defaults, options);
                    options.roundFactor = parseInt('1' + stringRepeat('0', options.precision));

                    this._name = pluginName;

                    var frontElement, backElement, separator, dragHandle, lastRatio = 1, size = {
                        width: 0,
                        height: 0,
                        maxWidth: 0,
                        maxHeight: 0
                    }, events = {
                        initialised: "imagesCompare:initialised",
                        changed: "imagesCompare:changed",
                        resized: "imagesCompare:resized"
                    };

                    function onImagesLoaded() {
                        var images = element.find('img'),
                            totalImagesCount = images.length,
                            elementsLoaded = 0;

                        function onImageLoaded() {
                            if (elementsLoaded >= totalImagesCount) {
                                init();
                            }
                        }

                        images.each(function () {
                            // Image already loaded (cached)
                            if ($(this)[0].complete) {
                                totalImagesCount--;
                                onImageLoaded();
                            } else {
                                // Image loading / error
                                $(this).on('load', function () {
                                    elementsLoaded++;
                                    onImageLoaded();
                                });
                                $(this).on('error', function () {
                                    elementsLoaded++;
                                    onImageLoaded();
                                });
                            }
                        });
                    }

                    onImagesLoaded();

                    function init() {
                        updateDom();
                        patchSize();
                        initInteractions();

                        $(frontElement).attr('ratio', options.initVisibleRatio);
                        setVisibleRatio(options.initVisibleRatio);

                        // Let the world know we have done the init
                        element.trigger({
                            type: events.initialised
                        });
                    }

                    function addResize() {
                        $(window).on('resize', function (event) {
                            frontElement.css('clip', '');
                            patchSize();
                            setVisibleRatio(lastRatio);

                            // Let the world know we have done some resize updates
                            element.trigger({
                                type: events.resized,
                                originalEvent: event
                            });
                        });
                    }

                    function initInteractions() {
                        options.interactionMode = options.interactionMode.toLowerCase();

                        if (options.interactionMode != "drag" && options.interactionMode != "mousemove" && options.interactionMode != "click") {
                            console.warn('No valid interactionMode found, valid values are "drag", "mousemove", "click"');
                        }

                        switch (options.interactionMode) {
                            case "drag":
                                initDrag();
                                break;
                            case "mousemove":
                                initMouseMove();
                                break;
                            case "click":
                                initClick();
                                break;
                            default:
                                initDrag();
                        }
                    }

                    function initDrag() {
                        if (typeof Hammer == 'undefined') {
                            console.error('Please include the hammerjs library for drag support');
                        }
                        addDrag();
                        addResize();
                    }

                    function initMouseMove() {
                        addMouseMove();
                        addResize();
                    }

                    function initClick() {
                        addClick();
                        addResize();
                    }

                    function addClick() {
                        element.on('click', function (event) {
                            var ratio = getElementRatio(event.pageX);
                            setVisibleRatio(ratio);
                        });
                    }

                    function addMouseMove() {
                        var lastMove = 0;
                        var eventThrottle = 1;
                        element.on('mousemove', function (event) {
                            event.preventDefault();
                            var now = Date.now();
                            if (now > lastMove + eventThrottle) {
                                lastMove = now;
                                var ratio = getElementRatio(event.pageX);
                                setVisibleRatio(ratio);
                            }
                        });

                        element.on('mouseout', function (event) {
                            var ratio = getElementRatio(event.pageX);
                            setVisibleRatio(ratio);
                        });
                    }

                    function addDrag() {
                        var hammertime = new Hammer(element[0]);
                        hammertime.get('pan').set({direction: Hammer.DIRECTION_HORIZONTAL});
                        hammertime.on('pan', function (event) {
                            var ratio = getElementRatio(event.srcEvent.pageX);
                            setVisibleRatio(ratio);
                        });
                    }

                    function updateDom() {
                        element.addClass('images-compare-container');
                        element.css('display', 'inline-block');

                        frontElement = element.find('> *:nth-child(1)');
                        backElement = element.find('> *:nth-child(2)');

                        frontElement.addClass("images-compare-before");
                        frontElement.css('display', 'block');
                        backElement.addClass("images-compare-after");
                        backElement.css('display', 'block');

                        if (options.addDragHandle) {
                            buildDragHandle();
                        }

                        if (options.addSeparator) {
                            buildSeparator();
                        }
                    }

                    function buildSeparator() {
                        element.prepend("<div class='images-compare-separator'></div>");
                        separator = element.find(".images-compare-separator");

                    }

                    function buildDragHandle() {
                        element.prepend("<div class='images-compare-handle'></div>");
                        dragHandle = element.find(".images-compare-handle");
                        dragHandle.append("<span class='images-compare-left-arrow'></span>");
                        dragHandle.append("<span class='images-compare-right-arrow'></span>");
                    }

                    function patchSize() {
                        var imgRef = backElement.find('img').first();
                        setSize(imgRef.width(), imgRef.height(), imgRef.naturalWidth(), imgRef.naturalHeight());
                        element.css('max-width', size.maxWidth + 'px');
                        element.css('max-height', size.maxHeight + 'px');
                        frontElement.width(size.width);
                        frontElement.height(size.height);
                    }

                    /**
                     *
                     * @param x
                     * @return float
                     */
                    function getElementRatio(x) {
                        return roundRatio((x - element.offset().left) / frontElement.width());
                    }

                    /**
                     *
                     * @param ratio
                     * @return float
                     */
                    function roundRatio(ratio) {
                        ratio = Math.round((ratio * options.roundFactor)) / options.roundFactor;
                        if (ratio > 1) {
                            ratio = 1;
                        }

                        if (ratio < 0) {
                            ratio = 0;
                        }

                        return ratio;

                    }

                    /**
                     * Animation request
                     *
                     * @param startValue float
                     * @param endValue float
                     * @param duration value in ms
                     * @param easing linear or swing
                     */
                    function launchAnimation(startValue, endValue, duration, easing) {
                        $(frontElement).attr('ratio', startValue).animate({ratio: startValue}, {
                            duration: 0
                        });

                        $(frontElement).stop().attr('ratio', startValue).animate({ratio: endValue}, {
                            duration: duration,
                            easing: easing,
                            step: function (now) {
                                var width = getRatioValue(now);
                                lastRatio = now;
                                frontElement.attr('ratio', now).css('clip', 'rect(0, ' + width + 'px, ' + size.height + 'px, 0)');

                                if (options.addSeparator) {
                                    separator.css('left', width + 'px');
                                }

                                if (options.addDragHandle) {
                                    dragHandle.css('left', width + 'px');
                                }
                            },
                            done: function (animation, jumpedToEnd) {
                                var ratio = $(frontElement).attr('ratio');
                                // Let the world know something has changed
                                element.trigger({
                                    type: events.changed,
                                    ratio: ratio,
                                    value: getRatioValue(ratio),
                                    animate: true,
                                    animation: animation,
                                    jumpedToEnd: jumpedToEnd
                                });
                            }
                        });
                    }

                    /**
                     * Get value to reach, based on a ratio
                     *
                     * @param ratio float
                     * @return {number}
                     */
                    function getRatioValue(ratio) {
                        ratio = Math.round((ratio * options.roundFactor)) / options.roundFactor;
                        return Math.round(frontElement.width() * ratio);
                    }

                    /**
                     * Change visible ratio
                     *
                     * @param ratio float
                     * @param animate boolean Do we want an animation ?
                     * @param duration in ms
                     * @param easing 'swing', 'linear'
                     */
                    function setVisibleRatio(ratio, animate, duration, easing) {
                        if (typeof animate == 'undefined') {
                            animate = false;
                        }

                        var width = getRatioValue(ratio);

                        if (animate) {
                            var finalDuration = duration ? duration : options.animationDuration;
                            var finalEasing = easing ? easing : options.animationEasing;

                            launchAnimation(lastRatio, ratio, finalDuration, finalEasing);

                            // Let the world know something has changed
                            if (lastRatio != ratio) {
                                element.trigger({
                                    type: events.changed,
                                    ratio: lastRatio,
                                    value: width,
                                    animate: animate
                                });
                            }

                            return;

                        } else {
                            frontElement.stop().css('clip', 'rect(0, ' + width + 'px, ' + size.height + 'px, 0)');

                            if (options.addSeparator) {
                                $(separator).stop().css('left', width + 'px');
                            }

                            if (options.addDragHandle) {
                                dragHandle.css('left', width + 'px');
                            }
                        }

                        // Let the world know something has changed
                        if (lastRatio != ratio) {
                            element.trigger({
                                type: events.changed,
                                ratio: ratio,
                                value: width,
                                animate: animate
                            });
                        }

                        lastRatio = ratio;
                    }

                    function setSize(width, height, maxWidth, maxHeight) {
                        if (typeof width != 'undefined') {
                            setWidth(width);
                        }
                        if (typeof height != 'undefined') {
                            setHeight(height);
                        }
                        if (typeof maxWidth != 'undefined') {
                            setMaxWidth(maxWidth);
                        }
                        if (typeof maxHeight != 'undefined') {
                            setMaxHeight(maxHeight);
                        }
                        return size;
                    }

                    function setWidth(width) {
                        size.width = width;
                        return size;
                    }

                    function setMaxWidth(maxWidth) {
                        size.maxWidth = maxWidth;
                        return size;
                    }

                    function setHeight(height) {
                        size.height = height;
                        return size;
                    }

                    function setMaxHeight(maxHeight) {
                        size.maxHeight = maxHeight;
                        return size;
                    }

                    // public function declaration
                    // returning element to preserve chaining
                    return {
                        "setValue": function (ratio, animate, duration, easing) {
                            setVisibleRatio(ratio, animate, duration, easing);
                            return element;
                        },
                        "getValue": function () {
                            return lastRatio;
                        },
                        "on": function (eventName, callback) {
                            element.on(eventName, callback);
                            return element;
                        },
                        "off": function (eventName, callback) {
                            element.off(eventName, callback);
                            return element;
                        },
                        "events": function () {
                            return events;
                        }
                    };
                }


                /**
                 * Plugin declaration
                 *
                 * @param userOptions
                 * @return {*}
                 */
                $.fn.imagesCompare = function (userOptions) {
                    var options = $.extend(defaults, userOptions);
                    return this.each(function () {
                        if (!$.data(this, pluginName)) {
                            $.data(this, pluginName, new ImagesCompare(this, options));
                        }
                    });
                };

            })(jQuery, window, document);

// http://www.jacklmoore.com/notes/naturalwidth-and-naturalheight-in-ie/
            (function ($) {
                var props = ['Width', 'Height'], prop, propsLength;

                propsLength = props.length;

                for (var index = 0; index < propsLength; index++) {
                    prop = props[index];
                    /*jslint loopfunc: true */
                    (function (natural, prop) {
                        $.fn[natural] = (natural in document.createElement('img')) ?
                            function () {
                                return this[0][natural];
                            } :
                            function () {
                                var
                                    node = this[0],
                                    img,
                                    value = 0;

                                if (node.tagName.toLowerCase() === 'img') {
                                    img = document.createElement('img');
                                    img.src = node.src;
                                    value = img[prop];
                                }
                                return value;
                            };
                    }('natural' + prop, prop.toLowerCase()));
                    /*jslint loopfunc: false */
                }
            }(jQuery));
            $(function () {
                var imagesCompareElement = $('.js-img-compare').imagesCompare();
                var imagesCompare = imagesCompareElement.data('imagesCompare');
                var events = imagesCompare.events();
                imagesCompare.on(events.changed, function (event) {
                    console.log(events.changed);
                    console.log(event.ratio);
                    if (event.ratio < 0.4) {
                        console.log('We see more than half of the back image');
                    }
                    if (event.ratio > 0.6) {
                        console.log('We see more than half of the front image');
                    }
                    if (event.ratio <= 0) {
                        console.log('We see completely back image');
                    }
                    if (event.ratio >= 1) {
                        console.log('We see completely front image');
                    }
                });
                $('.js-front-btn').on('click', function (event) {
                    event.preventDefault();
                    imagesCompare.setValue(1, true);
                });
                $('.js-back-btn').on('click', function (event) {
                    event.preventDefault();
                    imagesCompare.setValue(0, true);
                });
                $('.js-toggle-btn').on('click', function (event) {
                    event.preventDefault();
                    if (imagesCompare.getValue() >= 0 && imagesCompare.getValue() < 1) {
                        imagesCompare.setValue(1, true);
                    } else {
                        imagesCompare.setValue(0, true);
                    }
                });
            });
        });

    </script>
</head>

<body>


<div class="container">
    <br>
    <br>
    <h1 style="align-content: center; text-align: center">Semantics-Controlled Gaussian Splatting for Outdoor Scene
        Reconstruction and Rendering in Virtual Reality</h1>
    <h5></h5>


    <div class="row" style="align-content: center; text-align: center">
        <div class="col-md-12"><img
                src="https://github.com/HannahHaensen/SCGS/blob/gh-pages/docs/assets/teaser.png?raw=true"
                style="width: 100%">
        </div>

    </div>
    <br>
    <div class="row" style="align-content: center; text-align: center">
        <div class="col-md-12">
            <b><a href="">Hannah Schieber
                <sup>1,3</sup></a>, Jacob Young
                <sup>2</sup>, Tobias Langlotz
                <sup>2</sup>, Stefanie Zollmann
                <sup>2</sup>, and Daniel Roth<sup>3</sup></b>
        </div>
    </div>
    <br>
    <div class="row" style="align-content: center; text-align: center">
        <div class="col-md-4 col-sm-6">
            Friedrich-Alexander University (FAU) Erlangen-Nurnberg,
            Erlangen, Germany
            <sup>1</sup>
        </div>
        <div class="col-md-4 col-sm-6">
            Department of Computer Science, University of Otago, Dunedin, New Zealand
            <sup>2</sup>
        </div>
        <div class="col-md-4 col-sm-12">
            Technical University of Munich, School of Medicine and Health, Klinikum rechts der Isar, Orthopaedics and
            Sports Orthopaedics, Munich, Germany
            <sup>3</sup>
        </div>
    </div>
    <br>
    <div class="row" style="align-content: center; text-align: center">

        <div class="col-md-4">
            <a href="https://www.arxiv.org/abs/2409.15959.pdf">
                <img src="https://github.com/HannahHaensen/SCGS/blob/gh-pages/docs/assets/paper.png?raw=true"
                     style="width: 50px; border: 1px black solid"></a>
            <p>arixv</p>
        </div>
        <div class="col-md-4">
            <a href="https://github.com/HannahHaensen/SCGS">
                <img src="https://github.com/HannahHaensen/SCGS/blob/gh-pages/docs/assets/code.png?raw=true"
                     style="width: 50px; border: 1px black solid"></a>
            <p>Code (coming soon)</p>
        </div>
        <div class="col-md-4">
            <a href="https://osf.io/s9uvy/?view_only=eff198d8752840e69a9f2b8c1c10b0a0">
                <img src="https://github.com/HannahHaensen/SCGS/blob/gh-pages/docs/assets/dataset.png?raw=true"
                     style="width: 300px; border: 1px black solid"></a></a>
            <p>Dataset</p>
        </div>
    </div>
    <br>
    <div class="row">
        <h3>Abstract</h3>
        <div class="col-md-12">
            Advancements in 3D rendering like Gaussian Splatting (GS) allow novel view synthesis and real-time rendering
            in virtual reality (VR). However, GS-created 3D environments are often difficult to edit. For scene
            enhancement or to incorporate 3D assets, segmenting Gaussians by class is essential. Existing segmentation
            approaches are typically limited to certain types of scenes, e.g., ''circular'' scenes, to determine clear
            object boundaries. However, this method is ineffective when removing large objects in non-''circling''
            scenes such as large outdoor scenes. We propose Semantics-Controlled GS (SCGS), a segmentation-driven GS
            approach, enabling the separation of large scene parts in uncontrolled, natural environments. SCGS allows
            scene editing and the extraction of scene parts for VR. Additionally, we introduce a challenging outdoor
            dataset, overcoming the ''circling'' setup. We outperform the state-of-the-art in visual quality on our
            dataset and in segmentation quality on the 3D-OVS dataset. We conducted an exploratory user study, comparing
            a 360-video, plain GS, and SCGS in VR with a fixed viewpoint. In our subsequent main study, users were
            allowed to move freely, evaluating plain GS and SCGS. Our main study results show that participants clearly
            prefer SCGS over plain GS. We overall present an innovative approach that surpasses the state-of-the-art
            both technically and in user experience.
        </div>
    </div>
    <br>
    <br>
    <div class="row">
        <h3>Architecture</h3>

    </div>
    <div class="row">
        <div class="col-md-12">
            <img style="width: 100%"
                 src="https://github.com/HannahHaensen/SCGS/blob/gh-pages/docs/assets/arch.jpg?raw=true">
        </div>
    </div>
    <br>
    <br>
    <div class="row">
        <h3>Evaluation</h3>
        <div class="container">

            <br>
            <hr>
            <h5>Novel View Synthesis</h5>
            <br>
            <div class="row">

                <div class="col-lg-6 col-sm-12">
                    <span>Outback Scene</span>
                    <br>
                    <!-- Beginn Bildwechsel -->
                    <div class="js-img-compare">
                        <div style="display: none;">
                            <span class="images-compare-label">Gaussian Grouping</span>
                            <img src="assets/gg/00002.png" alt="Before">
                        </div>
                        <div>
                            <span class="images-compare-label">Ours</span>
                            <img src="assets/ours/00002.png" alt="After">
                        </div>
                    </div>
                    <!-- Ende Bildwechsel -->
                </div>
                <div class="col-lg-6 col-sm-12">
                    <span>Outback Scene</span>
                    <br>
                    <!-- Beginn Bildwechsel -->
                    <div class="js-img-compare">
                        <div style="display: none;">
                            <span class="images-compare-label">Gaussian Grouping <br> (improved labels)</span>
                            <img src="assets/ggours/00002.png" alt="Before">
                        </div>
                        <div>
                            <span class="images-compare-label">Ours</span>
                            <img src="assets/ours/00002.png" alt="After">
                        </div>
                    </div>
                    <!-- Ende Bildwechsel -->
                </div>
            </div>

            <br>
            <hr>
            <div class="row">
                <div class="col-lg-6 col-sm-12">
                    <span>Lake Scene</span>
                    <br>
                    <!-- Beginn Bildwechsel -->
                    <div class="js-img-compare">
                        <div style="display: none;">
                            <span class="images-compare-label">Gaussian Grouping</span>
                            <img src="assets/gg/00023.png" alt="Before">
                        </div>
                        <div>
                            <span class="images-compare-label">Ours</span>
                            <img src="assets/ours/00023.png" alt="After">
                        </div>
                    </div>
                    <!-- Ende Bildwechsel -->
                </div>
                <div class="col-lg-6 col-sm-12">
                    <span>Open Sea Scene</span>
                    <br>
                    <!-- Beginn Bildwechsel -->
                    <div class="js-img-compare">
                        <div style="display: none;">
                            <span class="images-compare-label">Gaussian Grouping</span>
                            <img src="assets/gg/00011.png" alt="Before">
                        </div>
                        <div>
                            <span class="images-compare-label">Ours</span>
                            <img src="assets/ours/00011.png" alt="After">
                        </div>
                    </div>
                    <!-- Ende Bildwechsel -->
                </div>
            </div>

            <br>
            <hr>
            <h5>Object removal examples on the Short Ride scene</h5>
            <br>
            <div class="row">
                <div class="col-lg-6 col-sm-12">
                    <!-- Beginn Bildwechsel -->
                    <div class="js-img-compare">
                        <div style="display: none;">
                            <span class="images-compare-label">Gaussian Grouping  <br> (improved labels)  <br> (convex hull)</span>
                            <img src="assets/gg/removal.png" alt="Before">
                        </div>
                        <div>
                            <span class="images-compare-label">Ours</span>
                            <img src="assets/ours/removal.png" alt="After">
                        </div>
                    </div>
                    <!-- Ende Bildwechsel -->
                </div>
                <div class="col-lg-6 col-sm-12">
                    <!-- Beginn Bildwechsel -->
                    <div class="js-img-compare">
                        <div style="display: none;">
                            <span class="images-compare-label">Gaussian Grouping <br> (improved labels)  <br> (direct removal)</span>
                            <img src="assets/gg/removal_our_methd.png" alt="Before">
                        </div>
                        <div>
                            <span class="images-compare-label">Ours</span>
                            <img src="assets/ours/removal.png" alt="After">
                        </div>
                    </div>
                    <!-- Ende Bildwechsel -->
                </div>
            </div>

            <br>
            <hr>
            <h5>Object Removal on other scenes</h5>
            <br>
            <div class="row">
                <div class="col-lg-6 col-sm-12">
                    <span>Street Scene shot with Insta360 X1</span>
                    <br>
                    <!-- Beginn Bildwechsel -->
                    <div class="js-img-compare">
                        <div style="display: none;">
                            <span class="images-compare-label">Full (Ours)</span>
                            <img src="assets/ours/street_full.png" alt="Before">
                        </div>
                        <div>
                            <span class="images-compare-label">Removed (Ours)</span>
                            <img src="assets/ours/street_removed.png" alt="After">
                        </div>
                    </div>
                    <!-- Ende Bildwechsel -->
                </div>
                <div class="col-lg-6 col-sm-12">
                    <span>Kayak Scene shot with Insta360 X3</span>
                    <br>
                    <!-- Beginn Bildwechsel -->
                    <div class="js-img-compare">
                        <div style="display: none;">
                            <span class="images-compare-label">Full (Ours)</span>
                            <img src="assets/ours/schloss.png" alt="Before">
                        </div>
                        <div>
                            <span class="images-compare-label">Removed (Ours)</span>
                            <img src="assets/ours/schloss_removed.png" alt="After">
                        </div>
                    </div>
                    <!-- Ende Bildwechsel -->
                </div>
            </div>

        </div>
        <br>
        <br>
        <br>
    </div>
    <br>
    <br>
    <div class="row">

        <h3>SCGS in Virtual Reality</h3>

        <br>
        <div class="col-md-12">
            <p>SCGS allows the removal of large scene parts and the replacment of it with virtual 3D assets.</p>
        </div>
        <br>
    </div>
    <div class="row">
        <div class="col-md-12">
            <img style="width: 100%"
                 src="https://github.com/HannahHaensen/SCGS/blob/gh-pages/docs/assets/con_main.jpg?raw=true">
        </div>
    </div>
    <br>
    <br>
    <h3>Citation</h3>
    <div class="row">
        <div class="col-md-12">
            <p style="background: lightgray; margin: 10px; padding: 10px;">
                @misc{schieber2024semanticscontrolledgaussiansplattingoutdoor, <br>
                &nbsp&nbsp title={Semantics-Controlled Gaussian Splatting for Outdoor Scene Reconstruction and Rendering
                in Virtual
                Reality}, <br>
                &nbsp&nbsp author={Hannah Schieber and Jacob Young and Tobias Langlotz and Stefanie Zollmann and Daniel
                Roth}, <br>
                &nbsp&nbsp year={2024}, <br>
                &nbsp&nbspeprint={2409.15959}, <br>
                &nbsp&nbsparchivePrefix={arXiv}, <br>
                &nbsp&nbspprimaryClass={cs.CV}, <br>
                &nbsp&nbspurl={https://arxiv.org/abs/2409.15959}, <br>
                }
            </p>
        </div>
    </div>
</div>


</body>
</html>
